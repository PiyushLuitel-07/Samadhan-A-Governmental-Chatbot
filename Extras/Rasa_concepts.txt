Pipeline--incoming messages are processed through a sequence of many components..this process is pipeline

policies--chatbot uses policies to decide which action to take at each step in a conversation.there are machine learning and rule-based policies that our chatbot can use.Policies determine the behavior of the dialogue management system. They decide how the assistant should respond to a given user input based on the predicted intent, entities, and the conversation history. Rasa supports various policies, including rule-based, machine learning-based, and ensemble policies.Policies play a crucial role in deciding the next action the chatbot should take.

# lets understand pipeline
language: en
pipeline:
  - name: SpacyNLP
  - name: SpacyTokenizer
  - name: SpacyFeaturizer
  - name: RegexFeaturizer
  - name: LexicalSyntacticFeaturizer
  - name: CountVectorsFeaturizer
  - name: CountVectorsFeaturizer
    analyzer: "char_wb"
    min_ngram: 1
    max_ngram: 4
  - name: DIETClassifier
    epochs: 100
  - name: EntitySynonymMapper
  - name: ResponseSelector
    epochs: 100

explanation:
SpacyNLP: This component uses the spaCy natural language processing library to process and understand the input text. It provides tokenization, part-of-speech tagging, named entity recognition, and other language processing capabilities.

SpacyTokenizer: It tokenizes the input text using the spaCy tokenizer. Tokenization involves breaking down the input text into individual words or tokens.

SpacyFeaturizer: This component extracts features from the tokenized text using spaCy. These features are used to train the machine learning models.

RegexFeaturizer: It allows you to define custom regex patterns to extract features from the text. This is useful for capturing specific patterns or entities in the input.

LexicalSyntacticFeaturizer: This featurizer captures both lexical and syntactic features from the input text. It helps in creating a rich representation of the language structure.

CountVectorsFeaturizer: This featurizer converts the tokenized text into numerical features. It represents the frequency of words in a vector format, making it suitable for training machine learning models.

CountVectorsFeaturizer (char_wb): Another instance of CountVectorsFeaturizer with specific settings. It uses character-level n-grams (subsequences of characters) with a minimum and maximum length specified.

DIETClassifier: This is a machine learning-based intent classifier provided by Rasa. It uses a combination of intent and entity recognition in a joint model. The model is trained for 100 epochs.

EntitySynonymMapper: It maps synonymous entities to a common representation. This helps improve entity recognition by treating synonyms as the same entity.

ResponseSelector: This component is used for response selection. It helps in choosing the most appropriate response from a predefined set of responses. The model is trained for 100 epochs.

In summary, this pipeline combines various components to process and understand user input in a conversational AI system, utilizing spaCy for NLP, regex for custom pattern matching, and machine learning-based models for intent and entity recognition. The pipeline is designed to handle a range of natural language understanding tasks in a conversational context.

#lets understand policy
1.Rule-Based Policies:

Rule policies allow you to define explicit rules that specify how the assistant should behave in certain situations.
Rules are written in a format like "if X, then do Y."
Example:
- rule: Welcome the user
  steps:
  - intent: greet
  - action: utter_greet

2.Machine Learning-Based Policies:

Machine learning policies use models trained on data to predict the next action.
Examples include TEDPolicy (Transformers Embedding Dialogue Policy) and DIETClassifier (Dual Intent Entity Transformer Classifier).
example
policies:
  - name: DIETClassifier
    epochs: 100

3.Ensemble Policies:

Ensemble policies combine the predictions of multiple individual policies to make a final decision.
example
policies:
  - name: RulePolicy
  - name: TEDPolicy
    max_history: 5
  - name: MappingPolicy

Each policy contributes to the decision-making process, and the order in which they are listed in the configuration matters. The policies are evaluated sequentially, and the first policy that predicts a valid action is used. Ensemble policies combine the predictions of their sub-policies to make a final decision.


#Static and dynamic message
Static message are independent to the user input and doesnt need action server.
Dynamic message are dependent on user input,it needs action server, and some logic implementation.Example,user ask what are the items present in today's menu?. Now it must search from database.this need to be implemented logically and required action server.

#Intent Classification and Entity Extraction
This is done by Rasa NLU
example :: "I want to book a hotel for 3 people"
output:
{
"intent":"booking",
"entities":{
"person_count":3
}
}

For example, for the sentence "I am looking for Chinese food", the output is:

{
    "text": "I am looking for Chinese food",
    "entities": [
        {
            "start": 8,
            "end": 15,
            "value": "chinese",
            "entity": "cuisine",
            "extractor": "DIETClassifier",
            "confidence": 0.864
        }
    ],
    "intent": {"confidence": 0.6485910906220309, "name": "restaurant_search"},
    "intent_ranking": [
        {"confidence": 0.6485910906220309, "name": "restaurant_search"},
        {"confidence": 0.1416153159565678, "name": "affirm"}
    ]
}


next things:
intent:
	-i want to book a [flight](service) for [3](p_counts) people
	-book a [flight](service) for [9](p_count) people

now me must add these entities into domain.yml 
entities:
	- service
	- p_count

as we have made changes, we must train the rasa model
coding:
1.add intent in nly.yml
2.add those intents in domain.yml
3.the specify conversation flow in story file


#Slot
Slot is a chatbot memory.
Stores useful information from user message and we can access this information later.
slots are used to store information that can be referenced and updated throughout a conversation.
They represent pieces of data that the assistant needs to keep track of, such as user preferences, context, or any other relevant information. 
Slots play a crucial role in maintaining context and ensuring that the assistant understands and responds appropriately to user inputs.

types:
text slot -string valu e
boolean slot -true ,false ,0,1
categorical slot -high,medium,low
float slot - decimal values
list slot - stores a list of values
unfeaturized slot -any time of value ,this is mostly used
any slot - 

We use slot to store single information
We use forms to store lots of information from the user

#Forms
One of the most common conversation patterns is to collect a few pieces of information from a user

class structure needed to specify a form:
class name(FormAction): // this class is inherited from FormAction class
	def name(self):
	def required_slots(self):
	def submit(self):

we generally prefer Forms rather than slots

Domain file should contain:
intents:
..........
entities:
.........
slots:
...........
actions:
..........
forms:
..........
responses:
...........

main difference between a rule and story is that , a story can be seen as an example to learn from, while a rule is a pattern that the assistance must follow.

rules provide a way to describe short pieces of conversations that should always go the same way

when an entity is extracted, the output of the entity extraction is a snippet of JSON which contains entity category,entity value,confidence levels, component that extracted the entity.


#slots:
slots are long term memory in conversation.
they are like variable.  
they store information for later use.
any information can be stored in slot,even if no entity is detected.
Commonly we fill a slot value with detected entity value.
defined in domain.yml
they can influence the conversation.

Note that if slot is being filled by entity,slot must have same name of that entity

example:
entities:
- app_name
slots:
  app_name:
	type: text
	influence_conversation: true
	mappings:
	- type: from_entity
	  entity: app_name

Here the moment the entity app_name gets detected,slot gets filled immediately

mappings in slot can be from_entity, from_intent


#Rasa Form
used to collect information from the user.
this process is also called slot filling.

example:

slots:
	smoking_history:
	 	type: text
	 	influence_conversation: true
	 	mappings:
		  -type: from_entity
		   entity: smoking_history
	           condition: 
			- active_loop: lung_cancer_form

forms:
	lung_cancer_form:
		required slots:
		 - smoking_history
		 - secondhand_smoke

#explanation of above code:
smoking_history Slot:
Type: text - It is a text slot, meaning it can store textual information.
influence_conversation: true - Indicates that changes in this slot value should be considered when determining the next action or predicting user intent.
Mappings:
Mapping Type: from_entity - Specifies that the slot value should be filled from an entity recognized in the user's message.
Entity: smoking_history - Indicates that the entity named "smoking_history" is expected to fill this slot.
Condition: Specifies that this mapping should only be applied when the conversation is in the "lung_cancer_form" active loop.
Forms Definition:
lung_cancer_form Form:
Specifies the name of the form as "lung_cancer_form."
Required Slots:
smoking_history: Indicates that the "smoking_history" slot is required to be filled during the execution of this form.
secondhand_smoke: Presumably, there is another slot named "secondhand_smoke," and it is also required to be filled during the execution of this form.

in stories,if this is written
stories:
- story: path1 
  steps:
   - intent: greet
   - action: utter_greet
   - intent: utter_continue
   - action: affirm
   - intent: utter_start
   - action: lung_Cancer_form
   - active_loop: lung_Cancer_form

use of active loop is= the conversation will be in the context of filling out this form until all necessary information is collected ie,until all slots are filled up

the code above ,represents a conversation flow where the user initiates the conversation with a greeting, expresses an intent to continue, indicates a desire to start a specific topic related to lung cancer, and the chatbot responds by initiating a form loop to collect information about lung cancer interactively. The form loop ensures that the chatbot stays in the context of collecting information about lung cancer until the relevant information is gathered from the user.

next example
in rule.yml :
-rule: submit form
 condition:
 - active_loop: lung_cancer_form
steps:
- action: lung_cancer_from
- active_loop: null
- slot_was_set:
	- requested_slot: null








 









